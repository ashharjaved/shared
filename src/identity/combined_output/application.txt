

############## FILE PATH: application\__init__.py###########################

##################### END CONTENT#################################


############## FILE PATH: application\services\__init__.py###########################
from .auth_service import AuthService
from .tenant_service import TenantService
from .user_service import UserService

__all__=['AuthService','TenantService','UserService']
##################### END CONTENT#################################


############## FILE PATH: application\services\auth_service.py###########################
# src/identity/application/services/auth_service.py

import logging
from datetime import datetime
from typing import Dict, Optional
from uuid import UUID

from src.config import settings
from src.identity.domain.entities.user import User
from src.identity.domain.repositories.user_repository import UserRepository
from src.shared.events import log_security_event
from src.shared.exceptions import AuthenticationError, DomainError, AuthorizationError
from src.shared.security import verify_password, create_access_token, create_refresh_token

logger = logging.getLogger(__name__)


class AuthService:
    """
    Application service for authentication operations.
    
    Handles user login, token generation, and security controls
    like failed login attempt tracking and account lockouts.
    """
    
    def __init__(self, user_repository: UserRepository) -> None:
        self._user_repository = user_repository
    
    async def authenticate_user(
        self,
        email: str,
        password: str,
        tenant_id: UUID,
        correlation_id: str
    ) -> Dict[str, str]:
        """
        Authenticate user and return access/refresh tokens.
        
        Args:
            email: User email address
            password: Plain text password
            tenant_id: Tenant ID for user lookup
            correlation_id: Request correlation ID for logging
            
        Returns:
            Dictionary containing access_token and refresh_token
            
        Raises:
            AuthenticationError: If authentication fails
            AuthorizationError: If account is locked or inactive
        """
        # Find user by email and tenant
        user = await self._user_repository.find_by_email(email, tenant_id)
        
        if not user:
            await log_security_event(
                event="login_failed",
                tenant_id=tenant_id,
                email=email,
                reason="user_not_found",
                correlation_id=correlation_id
            )
            raise AuthenticationError("Invalid email or password")
        
        # Check if account is active
        if not user.is_active:
            await log_security_event(
                event="login_failed",
                tenant_id=tenant_id,
                user_id=user.id,
                email=email,
                reason="account_inactive",
                correlation_id=correlation_id
            )
            raise AuthorizationError("Account is inactive")
        
        # Check if account is verified
        if not user.is_verified:
            await log_security_event(
                event="login_failed",
                tenant_id=tenant_id,
                user_id=user.id,
                email=email,
                reason="account_not_verified",
                correlation_id=correlation_id
            )
            raise AuthorizationError("Account is not verified")
        
        # Check if account is locked due to failed attempts
        if user.is_locked:
            await log_security_event(
                event="login_failed",
                tenant_id=tenant_id,
                user_id=user.id,
                email=email,
                reason="account_locked",
                correlation_id=correlation_id
            )
            raise AuthorizationError(
                f"Account is locked due to {user.failed_login_attempts} failed login attempts"
            )
        
        # Verify password
        if not verify_password(password, user.password_hash):
            # Increment failed login attempts
            failed_attempts = await self._user_repository.increment_failed_logins(user.id)
            
            await log_security_event(
                event="login_failed",
                tenant_id=tenant_id,
                user_id=user.id,
                email=email,
                reason="invalid_password",
                failed_attempts=failed_attempts,
                correlation_id=correlation_id
            )
            
            # Check if account should be locked
            if failed_attempts >= settings.MAX_LOGIN_ATTEMPTS:
                await log_security_event(
                    event="account_locked",
                    tenant_id=tenant_id,
                    user_id=user.id,
                    email=email,
                    failed_attempts=failed_attempts,
                    correlation_id=correlation_id
                )
                raise AuthorizationError("Account has been locked due to too many failed attempts")
            
            raise AuthenticationError("Invalid email or password")
        
        # Successful authentication - reset failed attempts and update last login
        await self._user_repository.reset_failed_logins(user.id)
        await self._user_repository.update_last_login(user.id, datetime.utcnow())
        
        # Generate tokens
        access_token = create_access_token(
            sub=str(user.id),
            tenant_id=str(getattr(user, "tenant_id", "")),
            role=str(getattr(user, "role", "")),
            expires_delta==datetime.now()+7,
        )
        
        refresh_token = create_refresh_token(
            sub=str(user.id),
            tenant_id=str(getattr(user, "tenant_id", "")),
            role=user.role,
            expires_delta = datetime.utcnow() + (timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS))
        )
        
        await log_security_event(
            event="login_success",
            tenant_id=tenant_id,
            user_id=user.id,
            email=email,
            role=user.role.value,
            correlation_id=correlation_id
        )
        
        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_type": "bearer"
        }
    
    async def refresh_access_token(
        self,
        refresh_token: str,
        correlation_id: str
    ) -> Dict[str, str]:
        """
        Refresh an access token using a valid refresh token.
        
        Args:
            refresh_token: The refresh token
            correlation_id: Request correlation ID for logging
            
        Returns:
            Dictionary containing new access_token and refresh_token
            
        Raises:
            AuthenticationError: If refresh token is invalid
            AuthorizationError: If user is no longer active
        """
        from src.shared.security import decode_token, extract_user_id_from_token
        
        try:
            # Decode and validate refresh token
            payload = decode_token(refresh_token)
            
            if payload.get("type") != "refresh":
                raise AuthenticationError("Invalid token type")
            
            user_id = extract_user_id_from_token(refresh_token)
            
        except Exception:
            raise AuthenticationError("Invalid refresh token")
        
        # Get current user
        user = await self._user_repository.find_by_id(user_id)
        
        if not user or not user.can_login:
            await log_security_event(
                event="token_refresh_failed",
                user_id=user_id if user else None,
                tenant_id=UUID(payload["tenant_id"]) if "tenant_id" in payload else None,
                reason="user_inactive_or_not_found",
                correlation_id=correlation_id
            )
            raise AuthorizationError("User account is no longer active")
        
        # Generate new tokens
        access_token = create_access_token(
            sub=user.id,
            tenant_id=user.tenant_id,
            role=user.role.value,
            expires_delta = datetime.utcnow() + (timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS))
        )
        
        new_refresh_token = create_refresh_token(
            sub=user.id,
            tenant_id=user.tenant_id,
            role=user.role,
            expires_delta=settings.REFRESH_TOKEN_EXPIRE_DAYS
        )
        
        await log_security_event(
            event="token_refreshed",
            tenant_id=user.tenant_id,
            user_id=user.id,
            correlation_id=correlation_id
        )
        
        return {
            "access_token": access_token,
            "refresh_token": new_refresh_token,
            "token_type": "bearer"
        }
    
    async def logout_user(
        self,
        user_id: UUID,
        correlation_id: str
    ) -> None:
        """
        Log out a user (placeholder for token blacklisting).
        
        Args:
            user_id: The user ID
            correlation_id: Request correlation ID for logging
        """
        user = await self._user_repository.find_by_id(user_id)
        
        if user:
            await log_security_event(
                event="logout",
                tenant_id=user.tenant_id,
                user_id=user.id,
                correlation_id=correlation_id
            )
        
        # Note: In a production system, you would typically:
        # 1. Add the token to a blacklist (Redis)
        # 2. Or implement token versioning
        # 3. Or use short-lived tokens with refresh rotation
##################### END CONTENT#################################


############## FILE PATH: application\services\tenant_service.py###########################
# src/identity/application/services/tenant_service.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional

from src.shared.exceptions import AuthorizationError, DomainConflictError, NotFoundError
from src.shared.error_codes import ERROR_CODES
from src.shared.logging import log_event
from src.shared.roles import Role


@dataclass
class TenantService:
    tenant_repo: Any  # protocol: create, get_by_id, update_status, exists_by_name, etc.
    user_service: Any  # to seed initial admin if requested

    def _ensure_rls(self, tenant_id: Optional[str]) -> None:
        # For cross-tenant creation, SUPER/RESELLER can act without own-tenant RLS,
        # but we still require middleware to set context for write safety elsewhere.
        if tenant_id is None:
            # We don't strictly block SUPER_ADMIN here; RLS is enforced at DB policy level.
            pass

    def create_tenant(
        self,
        *,
        requester: Any,
        name: str,
        tenant_type: str,
        parent_id: Optional[str],
        plan: str,
        seed_admin: Optional[Dict[str, Any]] = None,
        correlation_id: Optional[str] = None,
    ) -> Any:
        """
        RBAC:
          - SUPER_ADMIN can create RESELLER and CLIENT (anywhere).
          - RESELLER_ADMIN can create CLIENT under itself (parent_id must be reseller's tenant).
        """
        req_role = getattr(requester, "role", "")
        req_tenant = getattr(requester, "tenant_id", None)

        # Authorization logic
        if req_role == Role.SUPER_ADMIN:
            pass
        elif req_role == Role.RESELLER_ADMIN:
            # Can only create CLIENT under itself
            if tenant_type != "CLIENT" or parent_id != req_tenant:
                raise AuthorizationError(ERROR_CODES["forbidden"]["message"], code="forbidden", status_code=403)
        else:
            raise AuthorizationError(ERROR_CODES["forbidden"]["message"], code="forbidden", status_code=403)

        # Uniqueness by name (optional constraint)
        if hasattr(self.tenant_repo, "exists_by_name") and self.tenant_repo.exists_by_name(name):
            raise DomainConflictError("Tenant name already exists", code="conflict", status_code=409)

        tenant = self.tenant_repo.create(
            name=name,
            tenant_type=tenant_type,
            parent_id=parent_id,
            plan=plan,
            is_active=True,
        )
        log_event(
            "TenantCreated",
            tenant_id=getattr(tenant, "id", None),
            user_id=getattr(requester, "id", None),
            correlation_id=correlation_id,
            tenant_type=tenant_type,
            parent_id=parent_id,
            plan=plan,
        )

        # Optionally seed initial admin in the new tenant
        if seed_admin:
            admin_role = seed_admin.get("role", Role.TENANT_ADMIN if tenant_type == "CLIENT" else Role.RESELLER_ADMIN)
            admin_payload = {
                "tenant_id": getattr(tenant, "id", None),
                "email": seed_admin["email"],
                "password": seed_admin.get("password"),
                "full_name": seed_admin.get("full_name"),
                "role": admin_role,
                "metadata": seed_admin.get("metadata") or {},
            }
            # SUPER_ADMIN can create; RESELLER_ADMIN can create ADMIN in its client
            self.user_service.create_user(requester=requester, data=admin_payload, correlation_id=correlation_id)

        return tenant

    def update_tenant_status(self, *, tenant_id: str, is_active: bool, correlation_id: Optional[str] = None) -> Any:
        tenant = self.tenant_repo.get_by_id(tenant_id)
        if not tenant:
            data_ec = ERROR_CODES["tenant_not_found"]
            raise NotFoundError(data_ec["message"], code="tenant_not_found", status_code=data_ec["http"])

        updated = self.tenant_repo.update_status(tenant_id, is_active=is_active)
        log_event(
            "TenantStatusUpdated",
            tenant_id=tenant_id,
            user_id=None,
            correlation_id=correlation_id,
            is_active=is_active,
        )
        return updated

##################### END CONTENT#################################


############## FILE PATH: application\services\user_service.py###########################
# src/identity/application/services/user_service.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional

from shared.roles import Role
from src.shared.exceptions import UnauthorizedError, DomainConflictError, NotFoundError, RlsNotSetError
from src.shared.error_codes import ERROR_CODES
from src.shared.logging import log_event
from src.shared import security


@dataclass
class UserService:
    user_repo: Any  # protocol: create, find_by_email, exists_by_email_in_tenant, get_by_id, change_role, deactivate, reactivate
    tenant_repo: Any  # protocol: get_by_id
    # Optional injectable hasher for testing
    password_hasher: Any = security.hash_password

    def _ensure_rls(self, tenant_id: Optional[str]) -> None:
        # RLS guard (GUC must be set by middleware). For now, enforce tenant present on requester.
        if not tenant_id:
            data = ERROR_CODES["rls_not_set"]
            raise RlsNotSetError(data["message"], code="rls_not_set", status_code=data["http"])

    def create_user(self, *, requester: Any, data: Dict[str, Any], correlation_id: Optional[str] = None) -> Any:
        """
        RBAC:
        - SUPER_ADMIN/RESELLER_ADMIN: can operate broader (scoped policy can evolve).
        - TENANT_ADMIN: can create STAFF only within same tenant.
        Enforce unique (tenant_id, email).
        """
        req_role = getattr(requester, "role", "")
        req_tenant = getattr(requester, "tenant_id", None)
        target_tenant = data.get("tenant_id") or req_tenant

        self._ensure_rls(req_tenant or target_tenant)

        # Role + tenant authorization
        if req_role == Role.SUPER_ADMIN:
            pass  # always allowed
        elif req_role == Role.RESELLER_ADMIN:
            # For now, same-tenant scope; extend to reseller tree later.
            if target_tenant != req_tenant:
                raise UnauthorizedError(ERROR_CODES["forbidden"]["message"], code="forbidden", status_code=403)
        elif req_role == Role.TENANT_ADMIN:
            if target_tenant != req_tenant or data.get("role") not in (Role.STAFF, ):
                raise AuthorizationError(ERROR_CODES["forbidden"]["message"], code="forbidden", status_code=403)
        else:
            raise AuthorizationError(ERROR_CODES["forbidden"]["message"], code="forbidden", status_code[403])

        # Ensure tenant exists
        tenant = self.tenant_repo.get_by_id(target_tenant)
        if not tenant:
            data_ec = ERROR_CODES["tenant_not_found"]
            raise NotFoundError(data_ec["message"], code="tenant_not_found", status_code=data_ec["http"])

        # Uniqueness in (tenant_id, email)
        email = data.get("email", "").lower().strip()
        if self.user_repo.exists_by_email_in_tenant(email=email, tenant_id=target_tenant):
            data_ec = ERROR_CODES["email_taken"]
            raise DomainConflictError(data_ec["message"], code="email_taken", status_code=data_ec["http"])

        # Hash password if provided
        password = data.get("password")
        password_hash = self.password_hasher(password) if password else None

        user = self.user_repo.create(
            tenant_id=target_tenant,
            email=email,
            role=data.get("role") or Role.STAFF,
            full_name=data.get("full_name"),
            password_hash=password_hash,
            is_active=True,
            metadata=data.get("metadata") or {},
        )
        log_event(
            "UserCreated",
            tenant_id=target_tenant,
            user_id=getattr(user, "id", None),
            correlation_id=correlation_id,
            created_by=getattr(requester, "id", None),
            role=getattr(user, "role", None),
        )
        return user

    def change_user_role(self, *, requester: Any, target_user_id: str, new_role: str,
                         correlation_id: Optional[str] = None) -> Any:
        req_role = getattr(requester, "role", "")
        req_tenant = getattr(requester, "tenant_id", None)
        self._ensure_rls(req_tenant)

        target = self.user_repo.get_by_id(target_user_id)
        if not target:
            data_ec = ERROR_CODES["user_not_found"]
            raise NotFoundError(data_ec["message"], code="user_not_found", status_code=data_ec["http"])

        if not Role.can_manage_user(req_role, req_tenant, target.role, target.tenant_id):
            data_ec = ERROR_CODES["forbidden"]
            raise AuthorizationError(data_ec["message"], code="forbidden", status_code=data_ec["http"])

        # Basic safety: cannot escalate above yourself
        if not security.has_min_role(req_role, new_role):
            data_ec = ERROR_CODES["role_change_not_allowed"]
            raise AuthorizationError(data_ec["message"], code="role_change_not_allowed", status_code=data_ec["http"])

        updated = self.user_repo.change_role(target_user_id, new_role)
        log_event(
            "UserRoleChanged",
            tenant_id=getattr(updated, "tenant_id", None),
            user_id=getattr(updated, "id", None),
            correlation_id=correlation_id,
            changed_by=getattr(requester, "id", None),
            new_role=new_role,
        )
        return updated

    def deactivate_user(self, *, requester: Any, target_user_id: str, correlation_id: Optional[str] = None) -> Any:
        req_role = getattr(requester, "role", "")
        req_tenant = getattr(requester, "tenant_id", None)
        self._ensure_rls(req_tenant)

        target = self.user_repo.get_by_id(target_user_id)
        if not target:
            data_ec = ERROR_CODES["user_not_found"]
            raise NotFoundError(data_ec["message"], code="user_not_found", status_code=data_ec["http"])

        if not security.can_manage_user(req_role, req_tenant, target.role, target.tenant_id):
            data_ec = ERROR_CODES["forbidden"]
            raise AuthorizationError(data_ec["message"], code="forbidden", status_code=data_ec["http"])

        updated = self.user_repo.deactivate(target_user_id)
        log_event(
            "UserDeactivated",
            tenant_id=getattr(updated, "tenant_id", None),
            user_id=getattr(updated, "id", None),
            correlation_id=correlation_id,
            deactivated_by=getattr(requester, "id", None),
        )
        return updated

    def reactivate_user(self, *, requester: Any, target_user_id: str, correlation_id: Optional[str] = None) -> Any:
        req_role = getattr(requester, "role", "")
        req_tenant = getattr(requester, "tenant_id", None)
        self._ensure_rls(req_tenant)

        target = self.user_repo.get_by_id(target_user_id)
        if not target:
            data_ec = ERROR_CODES["user_not_found"]
            raise NotFoundError(data_ec["message"], code="user_not_found", status_code=data_ec["http"])

        # Re-using same management rule
        if not Role.can_manage_user(req_role, req_tenant, target.role, target.tenant_id):
            data_ec = ERROR_CODES["forbidden"]
            raise AuthorizationError(data_ec["message"], code="forbidden", status_code=data_ec["http"])

        updated = self.user_repo.reactivate(target_user_id)
        log_event(
            "UserReactivated",
            tenant_id=getattr(updated, "tenant_id", None),
            user_id=getattr(updated, "id", None),
            correlation_id=correlation_id,
            reactivated_by=getattr(requester, "id", None),
        )
        return updated

##################### END CONTENT#################################
