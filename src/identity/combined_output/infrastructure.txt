

############## FILE PATH: infrastructure\models\tenant_model.py###########################
# src/identity/infrastructure/models/tenant_model.py

from datetime import datetime
from typing import Optional
from uuid import UUID

from sqlalchemy import Boolean, DateTime, ForeignKey, Index, String, UUID as SQLAlchemy_UUID
from sqlalchemy.dialects.postgresql import ENUM as PG_ENUM
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.sql import func
from identity.infrastructure.models.user_model import UserModel
from src.identity.domain.entities.tenant import SubscriptionPlan
from src.shared.database import Base
from src.identity.domain.entities.tenant import Tenant, TenantType

class TenantModel(Base):
    """SQLAlchemy model for tenants table."""
    
    __tablename__ = "tenants"
    
    id: Mapped[UUID] = mapped_column(
        SQLAlchemy_UUID(as_uuid=True),
        primary_key=True,
        server_default=func.gen_random_uuid()
    )
    name: Mapped[str] = mapped_column(String, unique=True, nullable=False)
    type: Mapped[TenantType] = mapped_column(
        PG_ENUM(TenantType, name="tenant_type_enum", create_type=False),
        nullable=False
    )
     
    parent_tenant_id: Mapped[Optional[UUID]] = mapped_column(
        SQLAlchemy_UUID(as_uuid=True),
        ForeignKey("tenants.id", ondelete="RESTRICT"),
        nullable=True
    )
    plan: Mapped[Optional["SubscriptionPlan"]] = mapped_column(
        PG_ENUM(SubscriptionPlan, name="subscription_plan_enum", create_type=False),
        nullable=True
    )
    is_active: Mapped[bool] = mapped_column(Boolean, nullable=False, default=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        server_default=func.now()
    )
    
    # Relationships
    users: Mapped[list["UserModel"]] = relationship(
        "UserModel",
        back_populates="tenant",
    )
    
    __table_args__ = (
        Index("idx_tenants_type", "type"),
        Index("ix_tenants_parent_tenant_id", "parent_tenant_id"),)
    
    def to_domain(self) -> Tenant:
        """Convert ORM model to domain entity."""
        return Tenant(
            id=self.id,
            name=self.name,
            type=self.type,
            parent_tenant_id=self.parent_tenant_id,
            plan=self.plan,
            is_active=self.is_active,
            created_at=self.created_at,
            updated_at=self.updated_at
        )
    
    @classmethod
    def from_domain(cls, tenant: Tenant) -> "TenantModel":
        """Create ORM model from domain entity."""
        return cls(
            id=tenant.id,
            name=tenant.name,
            type=tenant.type,
            parent_tenant_id=tenant.parent_tenant_id,
            plan=tenant.plan,
            is_active=tenant.is_active,
            created_at=tenant.created_at,
            updated_at=tenant.updated_at
        )
    
    def __repr__(self) -> str:
        return f"<TenantModel(id={self.id}, name='{self.name}', type={self.type})>"
##################### END CONTENT#################################


############## FILE PATH: infrastructure\models\user_model.py###########################
# src/identity/infrastructure/models/user_model.py

from datetime import datetime
from typing import Optional
from uuid import UUID

from sqlalchemy import (
    Boolean, DateTime, ForeignKey, Index, Integer, Text,
    UUID as SQLAlchemy_UUID, UniqueConstraint
)
from sqlalchemy.dialects.postgresql import ENUM as PG_ENUM
from sqlalchemy.dialects.postgresql import CITEXT
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.sql import func

from identity.infrastructure.models.tenant_model import TenantModel
from src.shared.database import Base
from src.identity.domain.entities.user import User
from shared.roles import Role


class UserModel(Base):
    """SQLAlchemy model for users table."""
    
    __tablename__ = "users"
    
    id: Mapped[UUID] = mapped_column(
        SQLAlchemy_UUID(as_uuid=True),
        primary_key=True,
        server_default=func.gen_random_uuid()
    )
    tenant_id: Mapped[UUID] = mapped_column(
        SQLAlchemy_UUID(as_uuid=True),
        ForeignKey("tenants.id", ondelete="RESTRICT"),
        nullable=False
    )
    email: Mapped[str] = mapped_column(CITEXT, nullable=False)
    password_hash: Mapped[str] = mapped_column(Text, nullable=False)
    role: Mapped[Role] = mapped_column(
        PG_ENUM(Role, name="user_role_enum", create_type=False),
        nullable=False
    )    
    is_active: Mapped[bool] = mapped_column(Boolean, nullable=False, default=True)
    is_verified: Mapped[bool] = mapped_column(Boolean, nullable=False, default=False)
    failed_login_attempts: Mapped[int] = mapped_column(Integer, nullable=False, default=0)
    last_login: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        server_default=func.now()
    )
    
    # Constraints
    __table_args__ = (
        UniqueConstraint("tenant_id", "email", name="uq_users_tenant_email"),
        Index("idx_users_tenant_role", "tenant_id", "role"),
        Index("idx_users_tenant", "tenant_id"),
        Index("idx_users_tenant_active", "tenant_id", "is_active"),    )
    
    # Relationships
    tenant: Mapped["TenantModel"] = relationship("TenantModel", back_populates="users")
    
    def to_domain(self) -> User:
        """Convert ORM model to domain entity."""
        return User(
            id=self.id,
            tenant_id=self.tenant_id,
            email=self.email,
            password_hash=self.password_hash,
            role=self.role,
            is_active=self.is_active,
            is_verified=self.is_verified,
            failed_login_attempts=self.failed_login_attempts,
            last_login=self.last_login,
            created_at=self.created_at,
            updated_at=self.updated_at
        )
    
    @classmethod
    def from_domain(cls, user: User) -> "UserModel":
        """Create ORM model from domain entity."""
        return cls(
            id=user.id,
            tenant_id=user.tenant_id,
            email=user.email,
            password_hash=user.password_hash,
            role=user.role,
            is_active=user.is_active,
            is_verified=user.is_verified,
            failed_login_attempts=user.failed_login_attempts,
            last_login=user.last_login,
            created_at=user.created_at,
            updated_at=user.updated_at
        )
    
    def __repr__(self) -> str:
        return f"<UserModel(id={self.id}, email='{self.email}', role={self.role})>"
##################### END CONTENT#################################


############## FILE PATH: infrastructure\repositories\tenant_repository_impl.py###########################
# src/identity/infrastructure/repositories/tenant_repository_impl.py

from typing import List, Optional
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError

from src.identity.domain.entities.tenant import Tenant
from src.identity.domain.repositories.tenant_repository import TenantRepository
from src.identity.infrastructure.models.tenant_model import TenantModel
from src.shared.exceptions import ConflictError, NotFoundError


class TenantRepositoryImpl(TenantRepository):
    """
    SQLAlchemy implementation of tenant repository.
    
    Handles tenant CRUD operations with proper error handling
    and domain/infrastructure mapping.
    """
    
    def __init__(self, session: AsyncSession) -> None:
        self._session = session
    
    async def create(self, tenant: Tenant) -> Tenant:
        """Create a new tenant."""
        try:
            model = TenantModel.from_domain(tenant)
            self._session.add(model)
            await self._session.flush()
            await self._session.refresh(model)
            return model.to_domain()
        except IntegrityError as e:
            await self._session.rollback()
            if "uq_tenants_name" in str(e) or "name" in str(e):
                raise ConflictError(f"Tenant name '{tenant.name}' already exists")
            raise ConflictError("Failed to create tenant due to constraint violation")
    
    async def find_by_id(self, tenant_id: UUID) -> Optional[Tenant]:
        """Find tenant by ID."""
        stmt = select(TenantModel).where(TenantModel.id == tenant_id)
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        return model.to_domain() if model else None
    
    async def find_by_name(self, name: str) -> Optional[Tenant]:
        """Find tenant by name."""
        stmt = select(TenantModel).where(TenantModel.name == name)
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        return model.to_domain() if model else None
    
    async def list_children(self, parent_id: UUID) -> List[Tenant]:
        """List all child tenants of a parent tenant."""
        stmt = select(TenantModel).where(TenantModel.parent_tenant_id == parent_id)
        result = await self._session.execute(stmt)
        models = result.scalars().all()
        return [model.to_domain() for model in models]
    
    async def update(self, tenant: Tenant) -> Tenant:
        """Update an existing tenant."""
        stmt = select(TenantModel).where(TenantModel.id == tenant.id)
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        
        if not model:
            raise NotFoundError(f"Tenant with ID {tenant.id} not found")
        
        try:
            # Update fields
            model.name = tenant.name
            model.type = tenant.type
            model.parent_tenant_id = tenant.parent_tenant_id
            model.plan = tenant.plan
            model.is_active = tenant.is_active
            model.updated_at = tenant.updated_at
            
            await self._session.flush()
            await self._session.refresh(model)
            return model.to_domain()
        except IntegrityError as e:
            await self._session.rollback()
            if "uq_tenants_name" in str(e) or "name" in str(e):
                raise ConflictError(f"Tenant name '{tenant.name}' already exists")
            raise ConflictError("Failed to update tenant due to constraint violation")
    
    async def list_all(self, limit: int = 100, offset: int = 0) -> List[Tenant]:
        """List all tenants with pagination."""
        stmt = select(TenantModel).limit(limit).offset(offset)
        result = await self._session.execute(stmt)
        models = result.scalars().all()
        return [model.to_domain() for model in models]
##################### END CONTENT#################################


############## FILE PATH: infrastructure\repositories\user_repository_impl.py###########################
# src/identity/infrastructure/repositories/user_repository_impl.py

from datetime import datetime
from typing import List, Optional
from uuid import UUID

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError

from src.identity.domain.entities.user import User
from src.identity.domain.repositories.user_repository import UserRepository
from shared.roles import Role
from src.identity.infrastructure.models.user_model import UserModel
from src.shared.exceptions import ConflictError, NotFoundError
from src.shared.database import set_rls_guc


class UserRepositoryImpl(UserRepository):
    """
    SQLAlchemy implementation of user repository with RLS enforcement.
    
    All operations automatically enforce tenant isolation through
    Row-Level Security policies.
    """
    
    def __init__(self, session: AsyncSession) -> None:
        self._session = session
    
    async def find_by_email(self, email: str, tenant_id: UUID) -> Optional[User]:
        """Find user by email within a tenant."""
        # Set tenant context for RLS
        await set_rls_guc(self._session, user_id=, tenant_id,)
        
        stmt = select(UserModel).where(
            UserModel.email == email,
            UserModel.tenant_id == tenant_id
        )
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        return model.to_domain() if model else None
    
    async def find_by_id(self, user_id: UUID) -> Optional[User]:
        """Find user by ID (with RLS enforcement)."""
        stmt = select(UserModel).where(UserModel.id == user_id)
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        return model.to_domain() if model else None
    
    async def save(self, user: User) -> User:
        """Create a new user."""
        # Set tenant context for RLS
        await set_tenant_guc(self._session, user.tenant_id)
        
        try:
            model = UserModel.from_domain(user)
            self._session.add(model)
            await self._session.flush()
            await self._session.refresh(model)
            return model.to_domain()
        except IntegrityError as e:
            await self._session.rollback()
            if "uq_users_tenant_email" in str(e) or "email" in str(e):
                raise ConflictError(f"User with email '{user.email}' already exists in tenant")
            raise ConflictError("Failed to create user due to constraint violation")
    
    async def update(self, user: User) -> User:
        """Update an existing user."""
        # Set tenant context for RLS
        await set_tenant_guc(self._session, user.tenant_id)
        
        stmt = select(UserModel).where(UserModel.id == user.id)
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        
        if not model:
            raise NotFoundError(f"User with ID {user.id} not found or not accessible")
        
        try:
            # Update fields
            model.email = user.email
            model.password_hash = user.password_hash
            model.role = user.role
            model.is_active = user.is_active
            model.is_verified = user.is_verified
            model.failed_login_attempts = user.failed_login_attempts
            model.last_login = user.last_login
            model.updated_at = user.updated_at
            
            await self._session.flush()
            await self._session.refresh(model)
            return model.to_domain()
        except IntegrityError as e:
            await self._session.rollback()
            if "uq_users_tenant_email" in str(e) or "email" in str(e):
                raise ConflictError(f"User with email '{user.email}' already exists in tenant")
            raise ConflictError("Failed to update user due to constraint violation")
    
    async def update_last_login(self, user_id: UUID, login_time: datetime) -> None:
        """Update user's last login timestamp."""
        stmt = (
            update(UserModel)
            .where(UserModel.id == user_id)
            .values(last_login=login_time, updated_at=datetime.utcnow())
        )
        result = await self._session.execute(stmt)
        
        if result.rowcount == 0:
            raise NotFoundError(f"User with ID {user_id} not found or not accessible")
    
    async def increment_failed_logins(self, user_id: UUID) -> int:
        """Increment failed login attempts counter."""
        stmt = (
            update(UserModel)
            .where(UserModel.id == user_id)
            .values(
                failed_login_attempts=UserModel.failed_login_attempts + 1,
                updated_at=datetime.utcnow()
            )
            .returning(UserModel.failed_login_attempts)
        )
        result = await self._session.execute(stmt)
        row = result.fetchone()
        
        if not row:
            raise NotFoundError(f"User with ID {user_id} not found or not accessible")
        
        return row[0]
    
    async def reset_failed_logins(self, user_id: UUID) -> None:
        """Reset failed login attempts counter to zero."""
        stmt = (
            update(UserModel)
            .where(UserModel.id == user_id)
            .values(failed_login_attempts=0, updated_at=datetime.utcnow())
        )
        result = await self._session.execute(stmt)
        
        if result.rowcount == 0:
            raise NotFoundError(f"User with ID {user_id} not found or not accessible")
    
    async def list_by_tenant(
        self,
        tenant_id: UUID,
        role: Optional[Role] = None,
        limit: int = 100,
        offset: int = 0
    ) -> List[User]:
        """List users in a tenant with optional role filtering."""
        # Set tenant context for RLS
        await set_tenant_guc(self._session, tenant_id)
        
        stmt = select(UserModel).where(UserModel.tenant_id == tenant_id)
        
        if role:
            stmt = stmt.where(UserModel.role == role)
        
        stmt = stmt.limit(limit).offset(offset)
        
        result = await self._session.execute(stmt)
        models = result.scalars().all()
        return [model.to_domain() for model in models]
##################### END CONTENT#################################
