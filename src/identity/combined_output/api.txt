

############## FILE PATH: api\__init__.py###########################
from .routes import tokens
from .routes import auth
from .routes import users

__all__=[]
##################### END CONTENT#################################


############## FILE PATH: api\schemas.py###########################
# src/identity/api/schemas.py
from __future__ import annotations
from typing import Optional
from pydantic import BaseModel, EmailStr, Field, ConfigDict


class LoginRequest(BaseModel):
    email: EmailStr
    password: str = Field(min_length=6, max_length=256)


class LoginResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
    expires_in: int
    refresh_token: Optional[str] = None


class UserCreate(BaseModel):
    email: EmailStr
    password: str = Field(min_length=6, max_length=256)
    role: str = Field(description="One of SUPER_ADMIN, RESELLER_ADMIN, TENANT_ADMIN, STAFF")


class UserRead(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: str
    email: EmailStr
    role: str
    is_active: bool
    is_verified: bool = False
    created_at: Optional[str] = None
    updated_at: Optional[str] = None


class TenantCreate(BaseModel):
    name: str = Field(min_length=2, max_length=200)
    tenant_type: str = Field(description="One of PLATFORM, RESELLER, CLIENT")
    parent_tenant_id: Optional[str] = Field(default=None)
    subscription_plan: str


class TenantRead(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: str
    name: str
    tenant_type: str
    subscription_plan: str
    is_active: bool
    created_at: Optional[str] = None
    updated_at: Optional[str] = None


# Optional helper for refresh/logout flows (used by auth routes)
class RefreshRequest(BaseModel):
    refresh_token: str


class TenantStatusUpdate(BaseModel):
    is_active: bool

##################### END CONTENT#################################


############## FILE PATH: api\routes\auth.py###########################
# src/identity/api/routes/auth.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, Request
from src.identity.api.schemas import LoginRequest, LoginResponse, RefreshRequest
from src.shared import security
from src.shared.exceptions import AuthenticationError, DomainError
from src.shared.error_codes import ERROR_CODES
from src.dependencies import get_user_repo
from src.identity.application.services.auth_service import AuthService

try:
    from src.config import ACCESS_TOKEN_TTL_SECONDS as ACCESS_TTL, REFRESH_TOKEN_TTL_SECONDS as REFRESH_TTL
except Exception:
    ACCESS_TTL, REFRESH_TTL = 3600, 30 * 24 * 3600  # defaults

router = APIRouter(prefix="/api/identity/auth", tags=["identity:auth"])


@router.post("/login", response_model=LoginResponse)
async def login(payload: LoginRequest, request: Request, user_repo=Depends(get_user_repo)) -> LoginResponse:
    service = AuthService(user_repo=user_repo)
    try:
        tokens = service.authenticate_user(email=payload.email, password=payload.password,tenant_id=payload.t correlation_id=request.headers.get("X-Correlation-ID"))
    except AuthenticationError as e:
        raise HTTPException(status_code=e.status_code, detail={"code": e.code, "message": str(e)})
    return LoginResponse(access_token=tokens["access_token"], refresh_token=tokens.get("refresh_token"), expires_in=ACCESS_TTL)


@router.post("/refresh", response_model=LoginResponse)
async def refresh(payload: RefreshRequest) -> LoginResponse:
    # Decode refresh token, validate type, and mint new access (and optionally a new refresh).
    try:
        claims = security.decode_token(payload.refresh_token)
        if claims.get("type") != "refresh":
            data = ERROR_CODES["invalid_credentials"]
            raise HTTPException(status_code=data["http"], detail={"code": "invalid_credentials", "message": "Invalid refresh token."})
        access = security.create_access_token(subject=claims["sub"], tenant_id=claims["tenant_id"], role=claims["role"], expires_in_seconds=ACCESS_TTL)
        # Optionally rotate refresh:
        refresh_token = security.create_refresh_token(subject=claims["sub"], tenant_id=claims["tenant_id"], role=claims["role"], expires_in_seconds=REFRESH_TTL)
        return LoginResponse(access_token=access, refresh_token=refresh_token, expires_in=ACCESS_TTL)
    except Exception:
        data = ERROR_CODES["invalid_credentials"]
        raise HTTPException(status_code=data["http"], detail={"code": "invalid_credentials", "message": "Invalid refresh token."})


@router.post("/logout", status_code=204)
async def logout() -> None:
    # If you maintain a refresh-token allowlist/denylist in Redis, revoke here.
    # Stateless JWT access tokens cannot be revoked without additional infra.
    return None

##################### END CONTENT#################################


############## FILE PATH: api\routes\tokens.py###########################
# src/identity/api/routes/tenants.py
from __future__ import annotations

from typing import List
from fastapi import APIRouter, Depends, HTTPException, Request

from shared.roles import Role
from src.identity.api.schemas import TenantCreate, TenantRead, TenantStatusUpdate
from src.identity.application.services.tenant_service import TenantService
from src.dependencies import get_current_user, get_tenant_repo, get_user_repo, require_role
from src.shared import security
from src.shared.exceptions import AuthorizationError, DomainConflictError, NotFoundError

router = APIRouter(prefix="/api/identity/tenants", tags=["identity:tenants"])


@router.post("", response_model=TenantRead, dependencies=[Depends(require_role(Role.RESELLER_ADMIN))])
async def create_tenant(
    payload: TenantCreate,
    request: Request,
    current_user = Depends(get_current_user),
    tenant_repo=Depends(get_tenant_repo),
    user_repo=Depends(get_user_repo),
) -> TenantRead:
    user_svc = __import__("src.identity.application.services.user_service", fromlist=["UserService"]).UserService(user_repo=user_repo, tenant_repo=tenant_repo)
    svc = TenantService(tenant_repo=tenant_repo, user_service=user_svc)
    try:
        tenant = svc.create_tenant(
            requester=current_user,
            name=payload.name,
            tenant_type=payload.tenant_type,
            parent_id=payload.parent_tenant_id,
            plan=payload.subscription_plan,
            seed_admin=None,  # optionally pass admin seed here
            correlation_id=request.headers.get("X-Correlation-ID"),
        )
        return TenantRead.model_validate(tenant)
    except (AuthorizationError, DomainConflictError) as e:
        raise HTTPException(status_code=e.status_code, detail={"code": e.code, "message": str(e)})


@router.get("", response_model=list[TenantRead], dependencies=[Depends(require_role(Role.RESELLER_ADMIN))])
async def list_tenants(
    current_user = Depends(get_current_user),
    tenant_repo=Depends(get_tenant_repo),
) -> list[TenantRead]:
    # Prefer domain query service method if it exists; else fallback.
    if hasattr(tenant_repo, "list_accessible"):
        items = await tenant_repo.list_accessible(current_user) if callable(getattr(tenant_repo, "list_accessible")) else tenant_repo.list_accessible(current_user)
    elif hasattr(tenant_repo, "list_all"):
        items = await tenant_repo.list_all() if callable(getattr(tenant_repo, "list_all")) else tenant_repo.list_all()
    else:
        items = []
    return [TenantRead.model_validate(t) for t in items]


@router.put("/{tenant_id}", response_model=TenantRead, dependencies=[Depends(require_role(Role.RESELLER_ADMIN))])
async def update_tenant_status(
    tenant_id: str,
    payload: TenantStatusUpdate,
    request: Request,
    tenant_repo=Depends(get_tenant_repo),
    user_repo=Depends(get_user_repo),
) -> TenantRead:
    user_svc = __import__("src.identity.application.services.user_service", fromlist=["UserService"]).UserService(user_repo=user_repo, tenant_repo=tenant_repo)
    svc = TenantService(tenant_repo=tenant_repo, user_service=user_svc)
    try:
        updated = svc.update_tenant_status(tenant_id=tenant_id, is_active=payload.is_active, correlation_id=request.headers.get("X-Correlation-ID"))
        return TenantRead.model_validate(updated)
    except NotFoundError as e:
        raise HTTPException(status_code=e.status_code, detail={"code": e.code, "message": str(e)})

##################### END CONTENT#################################


############## FILE PATH: api\routes\users.py###########################
# src/identity/api/routes/users.py
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, Request
from typing import Any

from shared.roles import Role
from src.identity.api.schemas import UserCreate, UserRead
from src.identity.application.services.user_service import UserService
from src.dependencies import get_current_user, get_user_repo, get_tenant_repo, require_role
from src.shared import security
from src.shared.exceptions import DomainError, NotFoundError, AuthorizationError, DomainConflictError
from src.shared.error_codes import ERROR_CODES

router = APIRouter(prefix="/api/identity/users", tags=["identity:users"])


@router.get("/me", response_model=UserRead)
async def me(current_user = Depends(get_current_user)) -> UserRead:
    return UserRead.model_validate(current_user)


@router.post("", response_model=UserRead, dependencies=[Depends(require_role(Role.TENANT_ADMIN))])
async def create_user(
    payload: UserCreate,
    request: Request,
    current_user = Depends(get_current_user),
    user_repo=Depends(get_user_repo),
    tenant_repo=Depends(get_tenant_repo),
) -> UserRead:
    svc = UserService(user_repo=user_repo, tenant_repo=tenant_repo)
    try:
        user = svc.create_user(requester=current_user, data=payload.model_dump(), correlation_id=request.headers.get("X-Correlation-ID"))
        return UserRead.model_validate(user)
    except (DomainConflictError, AuthorizationError, NotFoundError) as e:
        raise HTTPException(status_code=e.status_code, detail={"code": e.code, "message": str(e)})


@router.put("/{user_id}/role", response_model=UserRead, dependencies=[Depends(require_role(Role.TENANT_ADMIN))])
async def change_role(
    user_id: str,
    new_role: str,
    request: Request,
    current_user = Depends(get_current_user),
    user_repo=Depends(get_user_repo),
    tenant_repo=Depends(get_tenant_repo),
) -> UserRead:
    svc = UserService(user_repo=user_repo, tenant_repo=tenant_repo)
    try:
        user = svc.change_user_role(requester=current_user, target_user_id=user_id, new_role=new_role, correlation_id=request.headers.get("X-Correlation-ID"))
        return UserRead.model_validate(user)
    except (AuthorizationError, NotFoundError) as e:
        raise HTTPException(status_code=e.status_code, detail={"code": e.code, "message": str(e)})

##################### END CONTENT#################################
